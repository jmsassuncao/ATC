# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AutoTerrainClassification
                                 A QGIS plugin
 This plugin classifies sentinel 2 satellite imagery into 9 major terrain classes using machine learning algorithms for land use applications.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-13
        copyright            : (C) 2020 by Jorge Assunção
        email                : jms.assuncao@fct.unl.pt
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************
Packages dependencies:
Open OSGeoShell
type:
py3_env
pip install sklearn
pip install sentinelsat

extra dependencies used in the training procedure (not used in the final implementation)
shapely
pyshp
openpyxl
"""

__author__ = 'Jorge Assunção'
__date__ = '2020-04-13'
__copyright__ = '(C) 2020 by Jorge Assunção'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import sys
import inspect

from qgis.core import (
    QgsVectorLayer,
    QgsProject,
    QgsVectorLayerTools,
    QgsApplication,
    QgsProcessingUtils,
    QgsProcessingModelAlgorithm,
    QgsGeometry,
    QgsFeature,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsSymbolLayerUtils,
    QgsRasterLayer,
    QgsPointXY,
    QgsProcessingAlgorithm,
    QgsProcessing,
    QgsFeatureRequest,
    QgsTaskManager,
    QgsField,
    QgsVectorFileWriter,
    QgsFeedback,
    QgsMapLayer,
    QgsMapRendererParallelJob,
    QgsWkbTypes,
    QgsTask,
    Qgis,
    QgsMessageLog,
    QgsProcessingAlgRunnerTask,
    QgsApplication,
    QgsProcessingContext,
    QgsProcessingFeedback,
    QgsProject
)

# from plugins import processing
from plugins.processing.core.Processing import Processing as runAlgs

# initialize processing
runAlgs.initialize()
from qgis.PyQt import QtCore
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QProgressBar, QApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import *
from sentinelsat.sentinel import SentinelAPI
# import shapefile
from datetime import date, timedelta
from osgeo import gdal, osr
import time
import numpy as np
import re
import pandas as pd
import glob
from joblib import load
from collections import Counter
import zipfile
from .auto_terrain_classification_provider import AutoTerrainClassificationProvider
from .auto_terrain_classification_UI import Auto_terrain_classification_ui
from .auto_terrain_classification_crosshair import GetCoordinateCrossHair

# used to handle GUI scaling with higher resolution monitors
if hasattr(Qt, 'AA_EnableHighDpiScaling'):
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)


# get Plugin folder path
cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

# This step is necessary to prevent pandas from truncating text in "to_string" applications
pd.options.display.max_colwidth = 100


# noinspection PyTypeChecker,PyCallByClass
class AutoTerrainClassificationPlugin(object):

    def __init__(self, iface):
        self.provider = None
        self.iface = iface

        # set coordinate Reference system on transform and canvas (redundant)
        # self.crs = QgsCoordinateReferenceSystem.fromEpsgId(3763) # initially focused on Portugal
        self.crs = self.iface.mapCanvas().mapSettings().destinationCrs()
        self.iface.mapCanvas().mapSettings().setDestinationCrs(self.crs)
        self.transform = QgsCoordinateTransform()
        self.transform.setDestinationCrs(self.crs)
        self.transform.setSourceCrs(self.iface.mapCanvas().mapSettings().destinationCrs())
        self.transform_wgs84 = QgsCoordinateTransform()
        self.transform_wgs84.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:4326"))
        self.transform_wgs84.setSourceCrs(self.crs)

        # Create map tool and assign mouse click
        self.mapTool = GetCoordinateCrossHair(self.iface.mapCanvas())
        self.mapTool.mouseClicked.connect(self.mouseClicked)

        # set clicking order
        self.clickOrder = 1

        # initialize paths
        self.path_to_aux_layer = cmd_folder.replace("\\", "/") + "/files/Aux_layers/"
        self.path_to_dataframe_layer = cmd_folder.replace("\\", "/") + "/files/dataframes_layers/"
        self.path_to_training_images = cmd_folder.replace("\\", "/") + "/files/training_images/"
        self.path_to_trained_algorithms = cmd_folder.replace("\\", "/") + "/files/trained_algorithms/"
        self.path_to_sentinel_data = cmd_folder.replace("\\", "/") + "/files/sentinel_data/"
        self.path_to_resources = cmd_folder.replace("\\", "/") + "/files/Resources/"

        # initialize active layer as None
        self.active_labeled_layer = None

        # initialize square coordinate points as None
        self.first_clicked_gps_coordinates = None
        self.second_clicked_gps_coordinates = None

        # save aux layers to folder (true) or to memory (false)
        self.save_aux_to_folder = True

        # will be set False in run()
        self.first_start = True

        # initialize dialog as none
        self.dlg = None

        # initialize bar max value as 0
        self.barMaxValue = 0

        # initialize task related variables
        self.simplify_layer_task = None
        self.clip_layer_task = None
        self.clip_all_layers_task = None
        self.classify_layer_task = None
        self.create_raster_layer_task = None
        self.get_sentinel_data_task = None
        self.full_run_task = None

        # optimization comparison timer
        self.start_time = None

        # Message log tab
        self.log_category = "ATC Log"

        # Progress bars initialization
        self.progress_bar_simplify = None
        self.progress_bar_sentinel_download = None
        self.progress_bar_snip_all_layers = None
        self.progress_bar_classification = None

        # [remove] initialize tile location and labeled layer, used previously in training
        self.tile_location = "North(TPE)"
        self.labeled_layer = None

        # [remove] which images to get for classification
        self.images_from_sentinel = False

        # initialize copernicus account credentials
        self.username = None
        self.password = None

    def initProcessing(self):
        """Init Processing provider for QGIS >= 3.8."""
        self.provider = AutoTerrainClassificationProvider()
        QgsApplication.processingRegistry().addProvider(self.provider)

    def initGui(self):
        self.initProcessing()
        icon = os.path.join(os.path.join(cmd_folder, 'logo.png'))
        self.action = QAction(
            QIcon(icon),
            u"Auto Terrain Classification", self.iface.mainWindow())
        self.action.triggered.connect(self.run)
        self.iface.addPluginToMenu(u"&AutoTerrainClassification", self.action)
        self.iface.addToolBarIcon(self.action)

    def unload(self):
        QgsApplication.processingRegistry().removeProvider(self.provider)
        self.iface.removePluginMenu(u"&AutoTerrainClassification", self.action)
        self.iface.removeToolBarIcon(self.action)
        self.mapTool.deactivate()
        self.iface.mapCanvas().unsetMapTool(self.mapTool)


    def loadLabeledLayer(self):
        pre_message_log = "[loadLabeledLayer]: "
        if not QgsProject.instance().mapLayersByName("Portugal_Reduced_Labeling"):
            if self.labeled_layer.isValid():
                QgsProject.instance().addMapLayer(self.labeled_layer)
                QgsMessageLog.logMessage(pre_message_log + "Layer loaded.", self.log_category, level=Qgis.Info)
            else:
                QgsMessageLog.logMessage(pre_message_log + "Layer failed to load.", self.log_category,
                                         level=Qgis.Warning)
        else:
            QgsMessageLog.logMessage(pre_message_log + "Layer already loaded.", self.log_category, level=Qgis.Info)

    def run(self):
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False
            # link all the widgets in the plugin dialog to the respective functions
            self.dlg = Auto_terrain_classification_ui()
            self.dlg.pushButton_selectCoordinates.clicked.connect(self.captureCoordinates)
            self.dlg.pushButton_deactivateCoordinates.clicked.connect(self.deactivateCaptureCoordinates)
            self.dlg.pushButton_selectCoordinates_4.clicked.connect(self.disabledCoordinatesFunction)
            self.dlg.pushButton_deactivateCoordinates_4.clicked.connect(self.disabledCoordinatesFunction)
            self.dlg.pushButton_openRasterLayer.clicked.connect(self.openRasterLayer)
            self.dlg.pushButton_snipLayer.clicked.connect(self.snipLayer)
            self.dlg.pushButton_snipAllLayers.clicked.connect(self.snipAllLayers)
            self.dlg.pushButton_setActiveLayer.clicked.connect(self.setActiveLayer)
            self.dlg.checkBox_saveAuxLayersToFolder.clicked.connect(self.setAuxLayerSavingOption)
            self.dlg.radioButton_north.toggled.connect(self.setTileLocation)
            self.dlg.radioButton_center.toggled.connect(self.setTileLocation)
            self.dlg.radioButton_south.toggled.connect(self.setTileLocation)
            self.dlg.radioButton_sentinelimages.toggled.connect(self.setImageSource)
            self.dlg.radioButton_ownfolder.toggled.connect(self.setImageSource)
            self.dlg.pushButton_createRasterLayer.clicked.connect(self.createRasterLayer)
            self.dlg.pushButton_loadAccountDetails.clicked.connect(self.loadAccountDetails)
            self.dlg.pushButton_simplifyLabeledLayer.clicked.connect(self.simplifyLabeledLayer)
            self.dlg.pushButton_fullRun.clicked.connect(self.fullRun)
            self.dlg.mQgsFileWidget_rasterFileLocation.setFilter("*.tif")
            self.dlg.mQgsFileWidget_rasterFileLocation.setDefaultRoot(self.path_to_aux_layer[:-1])

        self.dlg.show()

    # [Start] Deactivated functions related with the creation of the training data set, can be skipped --------------

    def barProgressChangedFromSimplify(self, progress_point: int):
        pre_message_log = "[barProgressChangedFromSimplify]: "
        if progress_point == self.barMaxValue:  # Switch the bar text when the bar has reached completion
            self.progress_bar_simplify.setValue(progress_point)
            self.iface.messageBar().clearWidgets()
            progress_message_bar = self.iface.messageBar().createMessage(
                "Updating map's attribute table... (this process may take a while)")
            self.iface.messageBar().pushWidget(progress_message_bar, Qgis.Info)
        elif progress_point == -1:  # Arbitrary number, received as signal to close the widget
            self.iface.messageBar().clearWidgets()
            QgsMessageLog.logMessage(
                pre_message_log + "{}{} completed with result in {} seconds.".format(
                    pre_message_log, "Simplify Task", float(time.time() - self.start_time)),
                self.log_category, Qgis.Success)
        else:
            self.progress_bar_simplify.setValue(progress_point)

    def barProgressChangedFromSnipAllLayers(self, progress_point: int):
        pre_message_log = "[barProgressChangedFromSnipAllLayers]: "
        if progress_point == -1:  # Arbitrary number, received as signal to close the widget
            self.iface.messageBar().clearWidgets()
            QgsMessageLog.logMessage(pre_message_log + "Progress Bar Cleared.", self.log_category, Qgis.Success)
        else:
            self.progress_bar_snip_all_layers.setValue(progress_point)

    def snipLayer(self):
        pre_message_log = "[snipLayer]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        file_format = ".tif"
        log_category = "Snip Layer Task"

        # check to see if a name for the layer and the coordinate square were selected
        if self.first_clicked_gps_coordinates is not None and self.second_clicked_gps_coordinates is not None:
            layer_name_selected = self.dlg.lineEdit_layerName.text()
            if layer_name_selected == "":
                QgsMessageLog.logMessage(pre_message_log + "Give the layer a name before clipping",
                                         self.log_category, level=Qgis.Warning)
                return
            else:
                if os.path.isfile(self.path_to_aux_layer + layer_name_selected + file_format):
                    QgsMessageLog.logMessage(
                        pre_message_log + "layer name already in use, chose another before clipping",
                        self.log_category, level=Qgis.Warning)
                    return
            QgsMessageLog.logMessage(pre_message_log + "Clipping...", self.log_category, level=Qgis.Info)

            # create aux polygon to cut the layer
            layer_polygon_mask = QgsVectorLayer('Polygon', 'poly_aux', "memory")
            pr = layer_polygon_mask.dataProvider()
            polygon = QgsFeature()

            points = [self.first_clicked_gps_coordinates,
                      QgsPointXY(self.first_clicked_gps_coordinates.x(), self.second_clicked_gps_coordinates.y()),
                      self.second_clicked_gps_coordinates,
                      QgsPointXY(self.second_clicked_gps_coordinates.x(), self.first_clicked_gps_coordinates.y())]

            aux_polygon = QgsGeometry.fromPolygonXY([points])
            aux_valid_polygon = aux_polygon.makeValid()
            polygon.setGeometry(aux_valid_polygon)

            # polygon.setGeometry(QgsGeometry.fromPolygonXY([points]))
            pr.addFeatures([polygon])
            layer_polygon_mask.updateExtents()
            layer_polygon_mask.setCrs(self.crs)

            # Deactivate the clipping tool
            self.deactivateCaptureCoordinates()

            # Prints aux polygon layer on canvas
            # QgsProject.instance().addMapLayers([layer_polygon_mask])

            # define output folder for the snipped layer
            output_choice = self.path_to_aux_layer + layer_name_selected + file_format

            params = {
                "INPUT": self.active_labeled_layer,
                "MASK": layer_polygon_mask,
                "SOURCE_CRS": self.active_labeled_layer,
                "TARGET_CRS": self.crs,
                "NODATA": 0,
                "ALPHA_BAND": False,
                "CROP_TO_CUTLINE": True,
                "KEEP_RESOLUTION": False,
                "SET_RESOLUTION": True,  # False
                "X_RESOLUTION": 10,
                "Y_RESOLUTION": 10,
                "MULTITHREADING": False,
                "OPTIONS": "",
                "DATA_TYPE": 0,
                "EXTRA": None,
                "OUTPUT": output_choice}

            # create and assign a task to clip the intended layer
            self.clip_layer_task = SnipLabeledLayerTask("Snip labeled layer task")
            self.clip_layer_task.fillVariables(params, self.active_labeled_layer, layer_name_selected,
                                               self.path_to_aux_layer, self.path_to_resources, file_format)
            QgsApplication.taskManager().addTask(self.clip_layer_task)

        else:
            QgsMessageLog.logMessage(pre_message_log + "Layer area not selected", self.log_category, level=Qgis.Warning)

    def snipAllLayers(self):
        pre_message_log = "[snipAllLayers]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        file_format = ".tif"
        file_format_dataframe = ".csv"

        # check to see if a name for the layer and the coordinate square were selected
        if self.first_clicked_gps_coordinates is not None and self.second_clicked_gps_coordinates is not None:
            layer_name_selected = self.dlg.lineEdit_layerName.text()
            if layer_name_selected == "":
                QgsMessageLog.logMessage(pre_message_log + "Give the layer a name before clipping",
                                         self.log_category, level=Qgis.Warning)
                return
            else:
                if os.path.isfile(self.path_to_aux_layer + layer_name_selected + file_format):
                    QgsMessageLog.logMessage(
                        pre_message_log + "layer name already in use, chose another before clipping",
                        self.log_category, level=Qgis.Warning)
                    return
                if os.path.isfile(self.path_to_dataframe_layer + layer_name_selected + file_format_dataframe):
                    QgsMessageLog.logMessage(
                        pre_message_log + "dataframe (csv file) name already in use, chose another before clipping",
                        self.log_category, level=Qgis.Warning)
                    return

            QgsMessageLog.logMessage(pre_message_log + "Clipping...", self.log_category, level=Qgis.Info)

            # create aux polygon to cut the layer
            layer_polygon_mask = QgsVectorLayer('Polygon', 'poly_aux', "memory")
            pr = layer_polygon_mask.dataProvider()
            polygon = QgsFeature()

            # Adjusting points to create a polygon with extents equal to multiple of 10 (workaround for gdal clip task)
            first_point_x = int(self.first_clicked_gps_coordinates.x() / 10) * 10
            first_point_y = int(self.first_clicked_gps_coordinates.y() / 10) * 10

            second_point_x = int(self.first_clicked_gps_coordinates.x() / 10) * 10
            second_point_y = int(self.second_clicked_gps_coordinates.y() / 10) * 10

            third_point_x = int(self.second_clicked_gps_coordinates.x() / 10) * 10
            third_point_y = int(self.second_clicked_gps_coordinates.y() / 10) * 10

            fourth_point_x = int(self.second_clicked_gps_coordinates.x() / 10) * 10
            fourth_point_y = int(self.first_clicked_gps_coordinates.y() / 10) * 10

            points = [QgsPointXY(first_point_x, first_point_y),
                      QgsPointXY(second_point_x, second_point_y),
                      QgsPointXY(third_point_x, third_point_y),
                      QgsPointXY(fourth_point_x, fourth_point_y)]

            # create auxiliary polygon with the adjusted points
            aux_polygon = QgsGeometry.fromPolygonXY([points])
            aux_valid_polygon = aux_polygon.makeValid()
            polygon.setGeometry(aux_valid_polygon)

            # polygon.setGeometry(QgsGeometry.fromPolygonXY([points]))
            pr.addFeatures([polygon])
            layer_polygon_mask.updateExtents()
            layer_polygon_mask.setCrs(self.crs)

            # Deactivate the clipping tool
            self.deactivateCaptureCoordinates()

            # Prints aux polygon layer on canvas
            # QgsProject.instance().addMapLayers([layer_polygon_mask])

            # initialize progress bar
            self.progress_bar_snip_all_layers = QProgressBar()
            self.progress_bar_snip_all_layers.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            progress_message_bar = self.iface.messageBar().createMessage("Creating DataSet...")
            self.progress_bar_snip_all_layers.setMaximum(73)
            self.progress_bar_snip_all_layers.setMinimum(0)
            progress_message_bar.layout().addWidget(self.progress_bar_snip_all_layers)
            self.iface.messageBar().pushWidget(progress_message_bar, Qgis.Info)

            # create and assign a task to clip all the intended layer
            self.clip_all_layers_task = SnipAllLayersTask("Snip All layers task")
            self.clip_all_layers_task.task_progress_signal.connect(self.barProgressChangedFromSnipAllLayers)
            self.clip_all_layers_task.fillVariables(layer_polygon_mask, self.active_labeled_layer, layer_name_selected,
                                                    self.path_to_aux_layer, self.path_to_resources, file_format,
                                                    self.path_to_dataframe_layer, self.path_to_training_images,
                                                    file_format_dataframe,
                                                    self.tile_location, self.crs)
            QgsApplication.taskManager().addTask(self.clip_all_layers_task)

        else:
            QgsMessageLog.logMessage(pre_message_log + "Layer area not selected", self.log_category, level=Qgis.Warning)

    def openRasterLayer(self):
        pre_message_log = "[openRasterLayer]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # use the file selected in the widget search box
        aux_raster_file_selected = self.dlg.mQgsFileWidget_rasterFileLocation.filePath()

        if not aux_raster_file_selected:
            QgsMessageLog.logMessage(pre_message_log + "Select the layer file before opening",
                                     self.log_category, level=Qgis.Warning)
            return
        else:
            # switch backslashes with forward slashes if present
            raster_file_selected = aux_raster_file_selected.replace("\\", "/")
            # get base name of layer
            raster_name_selected = os.path.basename(raster_file_selected).replace(".tif", "")

        # open raster layer
        raster_layer = QgsRasterLayer(raster_file_selected, raster_name_selected)
        raster_layer.loadNamedStyle(self.self.path_to_resources + "Portugal_Reduced_Labeling_Raster.qml")
        raster_layer.setCrs(self.crs)
        if not QgsProject.instance().mapLayersByName(raster_name_selected):
            if raster_layer.isValid():
                QgsProject.instance().addMapLayer(raster_layer)
                QgsMessageLog.logMessage(pre_message_log + "Raster Layer loaded.", self.log_category, level=Qgis.Info)
            else:
                QgsMessageLog.logMessage(pre_message_log + "Raster Layer failed to load.", self.log_category,
                                         level=Qgis.Warning)
        else:
            QgsMessageLog.logMessage(pre_message_log + "Raster Layer already loaded.", self.log_category,
                                     level=Qgis.Info)
        return

    def setActiveLayer(self):
        pre_message_log = "[setActiveLayer]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # simply save the selected layer as the main active layer
        self.active_labeled_layer = self.iface.activeLayer()
        QgsMessageLog.logMessage("{}Active layer set to {}".format(pre_message_log, self.active_labeled_layer.name()),
                                 self.log_category, level=Qgis.Info)

    def setAuxLayerSavingOption(self):
        # function called every time saving option widget box is ticked
        pre_message_log = "[setAuxLayerSavingOption]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # update the variable
        if self.dlg.checkBox_saveAuxLayersToFolder.isChecked():
            self.save_aux_to_folder = True
            QgsMessageLog.logMessage(pre_message_log + "Will save auxilar layers to folder",
                                     self.log_category, level=Qgis.Info)
        else:
            self.save_aux_to_folder = False
            QgsMessageLog.logMessage(pre_message_log + "Will save auxiliar layers to memory",
                                     self.log_category, level=Qgis.Info)

    def setTileLocation(self, checked):
        # function called every time tile location widget box is ticked
        pre_message_log = "[setTileLocation]: "

        # prevents the function from running twice, when the checking and unchecking signals are sent from the groupbox
        if not checked:
            return

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # update the variable
        if self.dlg.radioButton_north.isChecked():
            self.tile_location = "North(TPE)"
            QgsMessageLog.logMessage(pre_message_log + "North tile selected",
                                     self.log_category, level=Qgis.Info)
        elif self.dlg.radioButton_center.isChecked():
            self.tile_location = "Center(SNC)"
            QgsMessageLog.logMessage(pre_message_log + "Center tile selected",
                                     self.log_category, level=Qgis.Info)
        elif self.dlg.radioButton_south.isChecked():
            self.tile_location = "South(SNB)"
            QgsMessageLog.logMessage(pre_message_log + "South tile selected",
                                     self.log_category, level=Qgis.Info)
        else:
            return
        return

    def setImageSource(self, checked):
        # function called every time image source option widget box is ticked

        pre_message_log = "[setImageSource]: "
        # prevents the function from running twice, when the checking and unchecking signals are sent from the groupbox
        if not checked:
            return

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # update the variable
        if self.dlg.radioButton_ownfolder.isChecked():
            self.images_from_sentinel = False
            QgsMessageLog.logMessage(pre_message_log + "Selected own folder as source for classification images",
                                     self.log_category, level=Qgis.Info)
        elif self.dlg.radioButton_sentinelimages.isChecked():
            self.images_from_sentinel = True
            QgsMessageLog.logMessage(
                pre_message_log + "Selected downloaded sentinel folders as source for classification images",
                self.log_category, level=Qgis.Info)
        else:
            return
        return

    def createRasterLayer(self):
        pre_message_log = "[createRasterLayer]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # check to see if any active layer is selected
        if self.active_labeled_layer is not None:
            extent = self.active_labeled_layer.extent()
        else:
            QgsMessageLog.logMessage(pre_message_log + "Chose an active layer before continuing!",
                                     self.log_category, level=Qgis.Warning)
            return

        # get raster layer from text widget box
        raster_name_selected = self.dlg.lineEdit_rasterLayerName.text()

        # check if the name form is empty
        if raster_name_selected == "":
            QgsMessageLog.logMessage(pre_message_log + "Select the layer a name before opening",
                                     self.log_category, level=Qgis.Warning)
            return
        else:
            if os.path.isfile(self.path_to_aux_layer + raster_name_selected + ".tif"):
                QgsMessageLog.logMessage(pre_message_log + "File name already exists in the directory",
                                         self.log_category, level=Qgis.Warning)
                return

        output_dir = self.path_to_aux_layer + raster_name_selected + ".tif"

        # pixel resolution in meters -> 10m*10m to be in line with the sentinel 2 lowest res
        xmin = extent.xMinimum()
        xmax = extent.xMaximum()
        ymin = extent.yMinimum()
        ymax = extent.yMaximum()
        pixel_resolution = 10

        # Create raster layer from shapefile
        params = {"INPUT": self.active_labeled_layer,
                  "FIELD": "Simplified",
                  "BURN": 0,
                  "WIDTH": pixel_resolution,
                  "HEIGHT": pixel_resolution,
                  "UNITS": 1,
                  "NODATA": 0,
                  "EXTENT": "%f,%f,%f,%f" % (xmin, xmax, ymin, ymax),
                  "INIT": 0,
                  "INVERT": False,
                  "ALL_TOUCH": 0,
                  "OPTIONS": '',
                  "DATA_TYPE": 5,
                  "EXTRA": None,
                  "OUTPUT": output_dir}

        # run gdal rasterize function with the selected params
        try:
            runAlgs.runAlgorithm('gdal:rasterize', params)
        except:
            QgsMessageLog.logMessage(pre_message_log + "Shapefile to raster algorythm failed.", self.log_category,
                                     level=Qgis.Critical)
            return

        # load recently created raster layer
        raster_layer = QgsRasterLayer(output_dir, raster_name_selected)
        raster_layer.loadNamedStyle(self.self.path_to_resources + "Portugal_Reduced_Labeling_Raster.qml")
        raster_layer.setCrs(self.crs)
        if not QgsProject.instance().mapLayersByName(raster_name_selected):
            if raster_layer.isValid():
                QgsProject.instance().addMapLayer(raster_layer)
                QgsMessageLog.logMessage(pre_message_log + "Raster Layer loaded.", self.log_category, level=Qgis.Info)
            else:
                QgsMessageLog.logMessage(pre_message_log + "Raster Layer failed to load.", self.log_category,
                                         level=Qgis.Warning)
        else:
            QgsMessageLog.logMessage(pre_message_log + "Raster Layer already loaded.", self.log_category,
                                     level=Qgis.Info)

        return

    def simplifyLabeledLayer(self):
        pre_message_log = "[simplifyLabeledLayer]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

        # check if labeled layer is active
        if self.active_labeled_layer is not None:
            layer = self.active_labeled_layer
        else:
            QgsMessageLog.logMessage(pre_message_log + "Chose a layer before continuing!",
                                     self.log_category, level=Qgis.Warning)
            return

        # check if field already exists (returns -1 if not found)
        field_exist = layer.fields().indexFromName("Simplified")
        if field_exist == -1:
            layer.dataProvider().addAttributes([QgsField('Simplified', QVariant.Int)])
            layer.updateFields()
        else:
            QgsMessageLog.logMessage(pre_message_log + "Simplified field already existed, skipping creation.",
                                     self.log_category, level=Qgis.Info)

        # initialize progress bar
        self.progress_bar_simplify = QProgressBar()
        self.progress_bar_simplify.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progress_message_bar = self.iface.messageBar().createMessage("Filling the new attribute field...")
        self.barMaxValue = layer.featureCount()
        self.progress_bar_simplify.setMaximum(self.barMaxValue)
        self.progress_bar_simplify.setValue(0)
        progress_message_bar.layout().addWidget(self.progress_bar_simplify)
        self.iface.messageBar().pushWidget(progress_message_bar, Qgis.Info)

        # Fill the new field with just the first number of some other field
        provider = layer.dataProvider()
        field_idx = provider.fields().indexFromName('Simplified')
        features = provider.getFeatures()

        QgsMessageLog.logMessage(pre_message_log + "Calling SimplifyLabeledLayerTask.",
                                 self.log_category, level=Qgis.Info)

        # initialize task and connect the progress bar
        self.simplify_layer_task = SimplifyLabeledLayerTask("Simplify labeled layer task")
        self.simplify_layer_task.task_progress_signal.connect(self.barProgressChangedFromSimplify)
        self.simplify_layer_task.fillVariables(features, field_idx, provider)
        self.start_time = time.time()
        QgsApplication.taskManager().addTask(self.simplify_layer_task)

    # [End] Deactivated functions related with the creation of the training data set, can be skipped --------------

    def loadAccountDetails(self):
        pre_message_log = "[loadAccountDetails]: "

        # Get text from credentials
        username_entry = self.dlg.lineEdit_userName_2.text()
        password_entry = self.dlg.lineEdit_passWord_2.text()

        # Check to see if any entry was left empty
        if username_entry == "" or password_entry == "" or username_entry is None or password_entry is None:
            self.username = None
            self.password = None
            QgsMessageLog.logMessage(pre_message_log + "Select a username and password first.", self.log_category,
                                     level=Qgis.Warning)
        else:
            self.username = username_entry
            self.password = password_entry
            QgsMessageLog.logMessage(pre_message_log + "Credentials filled!", self.log_category, level=Qgis.Info)

        return

    def captureCoordinates(self):
        # In case the user manually changed the map coordinate system since the start, reset coordinate system
        # start crosshair tool
        self.transform.setDestinationCrs(self.crs)
        self.transform.setSourceCrs(self.iface.mapCanvas().mapSettings().destinationCrs())
        self.iface.mapCanvas().setMapTool(self.mapTool)

    def deactivateCaptureCoordinates(self):
        # deactivate and clear crosshair tool from the canvas
        self.mapTool.deactivate()
        self.iface.mapCanvas().unsetMapTool(self.mapTool)
        self.iface.actionPan().trigger()

    def disabledCoordinatesFunction(self):
        pre_message_log = "[disabledCoordinatesFunction]: "

        # Function disabled. Function related with the creation of the original data set.
        QgsMessageLog.logMessage(pre_message_log + "Function disabled", self.log_category, level=Qgis.Info)
        return

    def mouseClicked(self, point_coordinates: QgsPointXY):
        # function is called every time the mouse is clicked in the crosshair tool mode
        pre_message_log = "[mouseClick]: "
        if self.clickOrder:
            # reset second coordinates (this is a fix)
            self.second_clicked_gps_coordinates = None
            second_clicked_gps_coordinates_wgs84 = None

            # transform coordinates from canvas points to the intended coordinate system and wgs84 for sentinelsat
            self.first_clicked_gps_coordinates = self.transform.transform(point_coordinates)
            first_clicked_gps_coordinates_wgs84 = self.transform_wgs84.transform(point_coordinates)

            # display gathered coordinates
            QgsMessageLog.logMessage('{0}Printing first GPS coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log, self.first_clicked_gps_coordinates.x(),
                                             self.first_clicked_gps_coordinates.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            QgsMessageLog.logMessage('{0}Printing first Canvas coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log, point_coordinates.x(), point_coordinates.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            QgsMessageLog.logMessage('{0}Printing first Canvas (4326) WGS84 coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log,
                                             first_clicked_gps_coordinates_wgs84.x(),
                                             first_clicked_gps_coordinates_wgs84.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            self.clickOrder = 0
        else:
            # the same as above, but for the second click
            self.second_clicked_gps_coordinates = self.transform.transform(point_coordinates)
            second_clicked_gps_coordinates_wgs84 = self.transform_wgs84.transform(point_coordinates)

            # display gathered coordinates
            QgsMessageLog.logMessage('{0}Printing second GPS coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log, self.second_clicked_gps_coordinates.x(),
                                             self.second_clicked_gps_coordinates.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            QgsMessageLog.logMessage('{0}Printing second Canvas coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log, point_coordinates.x(), point_coordinates.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            QgsMessageLog.logMessage('{0}Printing second Canvas (4326) WGS84 coordinates: {1:.{3}f},{2:.{3}f}'
                                     .format(pre_message_log,
                                             second_clicked_gps_coordinates_wgs84.x(),
                                             second_clicked_gps_coordinates_wgs84.y(), 3),
                                     self.log_category, level=Qgis.Info)
            QgsMessageLog.logMessage(pre_message_log + '------------------------------------', self.log_category,
                                     level=Qgis.Info)
            self.clickOrder = 1

    def barProgressChangedFromClassificationTask(self, progress_point: int):
        # create a progress bar when -2 is received, close the progressbar when -1 is received, update other values
        pre_message_log = "[barProgressChangedFromClassificationTask]: "
        if progress_point == -1:  # Arbitrary number, received as signal to close the widget
            self.iface.messageBar().clearWidgets()
            QgsMessageLog.logMessage(pre_message_log + "Progress Bar Cleared.", self.log_category, Qgis.Success)
            self.dlg.progressBar_inPlugin.setValue(0)
        elif progress_point == -2:
            # initialize progress bar
            self.progress_bar_classification = QProgressBar()
            self.progress_bar_classification.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            progress_message_bar = self.iface.messageBar().createMessage(
                "Extracting pixel data and predicting labels...")
            self.progress_bar_classification.setMaximum(100)
            self.progress_bar_classification.setMinimum(0)
            progress_message_bar.layout().addWidget(self.progress_bar_classification)
            self.iface.messageBar().pushWidget(progress_message_bar, Qgis.Info)
            self.dlg.progressBar_inPlugin.setValue(1)
        else:
            self.progress_bar_classification.setValue(progress_point)
            self.dlg.progressBar_inPlugin.setValue(progress_point)

    def barProgressChangedFromGetSentinelDataTask(self, progress_point: int):
        # create a progress bar when -2 is received, close the progressbar when -1 is received, update other values
        pre_message_log = "[barProgressChangedFromGetSentinelDataTask]: "
        if progress_point == -1:  # Arbitrary number, received as signal to close the widget
            self.iface.messageBar().clearWidgets()
            QgsMessageLog.logMessage(pre_message_log + "Progress Bar Cleared.", self.log_category, Qgis.Success)
            self.dlg.progressBar_inPlugin.setValue(0)
        elif progress_point == -2:
            # initialize progress bar
            self.progress_bar_sentinel_download = QProgressBar()
            self.progress_bar_sentinel_download.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            progress_message_bar = self.iface.messageBar().createMessage(
                "Downloading 3 tile images from Sentinel-2 ...")
            self.progress_bar_sentinel_download.setMaximum(100)
            self.progress_bar_sentinel_download.setMinimum(0)
            progress_message_bar.layout().addWidget(self.progress_bar_sentinel_download)
            self.iface.messageBar().pushWidget(progress_message_bar, Qgis.Info)
            self.dlg.progressBar_inPlugin.setValue(1)
        else:
            self.progress_bar_sentinel_download.setValue(progress_point)
            self.dlg.progressBar_inPlugin.setValue(progress_point)

    def fullRun(self):
        pre_message_log = "[fullRun]: "

        # Deactivate the clipping tool
        self.deactivateCaptureCoordinates()

        # check if the layer name was filled, if there is already a layer with that name and if there are coordinates saved
        if self.first_clicked_gps_coordinates is not None and self.second_clicked_gps_coordinates is not None:
            layer_name_selected = self.dlg.lineEdit_layerName_2.text()
            if layer_name_selected == "":
                QgsMessageLog.logMessage(pre_message_log + "Give the layer a name before clipping",
                                         self.log_category, level=Qgis.Warning)
                return
            else:
                if os.path.isfile(self.path_to_aux_layer + layer_name_selected + ".tif"):
                    QgsMessageLog.logMessage(
                        pre_message_log + "layer name already in use, chose another before clipping",
                        self.log_category, level=Qgis.Warning)
                    return
        else:
            QgsMessageLog.logMessage(pre_message_log + "Layer area not selected, select an area before clipping",
                                     self.log_category, level=Qgis.Warning)
            return

        # Recheck if the user credentials were filled
        if self.username == "" or self.password == "" or self.username is None or self.password is None:
            QgsMessageLog.logMessage(pre_message_log + "Make sure to load copernicus account credentials first!",
                                     self.log_category,
                                     level=Qgis.Warning)
            return

        # Define sentinelsat variables
        output_folder = self.path_to_sentinel_data[:-1]
        server = 'https://apihub.copernicus.eu/apihub/'  # https://scihub.copernicus.eu/dhus  or  https://apihub.copernicus.eu/apihub/  -> The server site to get the observations
        platform = 'Sentinel-2'  # Sentinel Platform
        processing_level = 'Level-2A'  # Level of processing  1C = top of atmosphere, 2A = Bottom of atmosphere
        cloud_cover = (0, 25)  # (min, max) cloud coverage

        # Get the coordinates for the polygon
        point1 = self.first_clicked_gps_coordinates
        point2 = QgsPointXY(self.first_clicked_gps_coordinates.x(), self.second_clicked_gps_coordinates.y())
        point3 = self.second_clicked_gps_coordinates
        point4 = QgsPointXY(self.second_clicked_gps_coordinates.x(), self.first_clicked_gps_coordinates.y())

        # the conversion of the points is done because geojson only works with "WGS84"
        polygon_transform = QgsCoordinateTransform()
        polygon_transform.setSourceCrs(self.crs)
        polygon_transform.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:4326"))  # WGS84

        # Get new set of converted points, parse as text,
        # and remove the comma in between in order to align with the footprint
        points_transformed = [polygon_transform.transform(point1).toString().replace(",", ""),
                              polygon_transform.transform(point2).toString().replace(",", ""),
                              polygon_transform.transform(point3).toString().replace(",", ""),
                              polygon_transform.transform(point4).toString().replace(",", "")]

        # The coordinates of the last point must coincide with the coordinates of the first point, rectangle -> 5 points
        footprint = "POLYGON((" \
                    + points_transformed[0] + "," \
                    + points_transformed[1] + "," \
                    + points_transformed[2] + "," \
                    + points_transformed[3] + "," \
                    + points_transformed[0] + "))"

        # Query Sentinel Products
        api = SentinelAPI(self.username, self.password, server, show_progressbars=False)

        # define 3 time intervals (season analogy),
        # 3 months apart from each other (counting from the start) and 2 months for each interval (to guarantee
        # the existence of images, later on filtered by cloud coverage and date) struct -> (begin_date, final_date)
        today = date.today()
        date_list = [(today - timedelta(days=60), today),
                     (today - timedelta(days=150), today - timedelta(days=90)),
                     (today - timedelta(days=240), today - timedelta(days=180))]

        # Query the sentinel database and create a list with the best tile from each season
        multi_temporal_product_list = []
        for dates in date_list:
            products = api.query(footprint,
                                 date=(dates[0], dates[1]),
                                 platformname=platform,
                                 processinglevel=processing_level,
                                 cloudcoverpercentage=cloud_cover)

            # convert to Pandas DataFrame
            products_df = api.to_dataframe(products)

            # sort and limit to the first 5 sorted product, only one is necessary for each season,
            # the 4 extra are backup downloads in case the file is corrupted. (sentinel has a lot of errors recently)
            products_df_sorted = products_df.sort_values(['cloudcoverpercentage', 'ingestiondate'],ascending=[True, True])
            products_df_sorted = products_df_sorted.head(5)

            # Append the products to the "to download" list
            multi_temporal_product_list.append(products_df_sorted)

        """
        for product_list in multi_temporal_product_list:
            QgsMessageLog.logMessage(pre_message_log + "Seasons",self.log_category, level=Qgis.Info)
            for index, product in product_list.iterrows():
                identifier = product['identifier'].strip()
                cloud_coverage = str(product['cloudcoverpercentage'])
                size = str(product['size'])
                on_demand = str(product['ondemand'])
                product_available = str(api.is_online(product['uuid'].strip()))
                QgsMessageLog.logMessage(pre_message_log + "File name to be downloaded: " + identifier,
                                         self.log_category, level=Qgis.Info)
                
                QgsMessageLog.logMessage(pre_message_log + "Cloud coverage: " + cloud_coverage,
                                         self.log_category, level=Qgis.Info)
                QgsMessageLog.logMessage(pre_message_log + "Size: " + size,
                                         self.log_category, level=Qgis.Info)
                QgsMessageLog.logMessage(pre_message_log + "on demand: " + on_demand,
                                         self.log_category, level=Qgis.Info)
                QgsMessageLog.logMessage(pre_message_log + "Is online: " + product_available,
                                         self.log_category, level=Qgis.Info)
        """

        # create the download task, fill it with the required information and link one signal
        # to update the progress bar. (task will be fed into the task manager at the end of the function)
        self.get_sentinel_data_task = GetSentinelDataTask2("Get sentinel data task")
        self.get_sentinel_data_task.task_progress_signal.connect(self.barProgressChangedFromGetSentinelDataTask)
        self.get_sentinel_data_task.fillVariables(self.iface, self.log_category, multi_temporal_product_list, api)

        # Classification process start ----------------------------------------------------------------------------------------------------------
        # create aux polygon to cut the layer
        layer_polygon_mask = QgsVectorLayer('Polygon', 'poly_aux', "memory")
        pr = layer_polygon_mask.dataProvider()
        polygon = QgsFeature()

        # Ajusting points to create a polygon with extents equal to multiple of 10 (workaround for gdal clip task)
        first_point_x = int(self.first_clicked_gps_coordinates.x() / 10) * 10
        first_point_y = int(self.first_clicked_gps_coordinates.y() / 10) * 10

        second_point_x = int(self.first_clicked_gps_coordinates.x() / 10) * 10
        second_point_y = int(self.second_clicked_gps_coordinates.y() / 10) * 10

        third_point_x = int(self.second_clicked_gps_coordinates.x() / 10) * 10
        third_point_y = int(self.second_clicked_gps_coordinates.y() / 10) * 10

        fourth_point_x = int(self.second_clicked_gps_coordinates.x() / 10) * 10
        fourth_point_y = int(self.first_clicked_gps_coordinates.y() / 10) * 10

        height_in_pixels = int(abs(first_point_y - third_point_y) / 10)
        length_in_pixels = int(abs(first_point_x - third_point_x) / 10)

        points = [QgsPointXY(first_point_x, first_point_y),
                  QgsPointXY(second_point_x, second_point_y),
                  QgsPointXY(third_point_x, third_point_y),
                  QgsPointXY(fourth_point_x, fourth_point_y)]

        aux_polygon = QgsGeometry.fromPolygonXY([points])
        aux_valid_polygon = aux_polygon.makeValid()
        polygon.setGeometry(aux_valid_polygon)

        # polygon.setGeometry(QgsGeometry.fromPolygonXY([points]))
        pr.addFeatures([polygon])
        layer_polygon_mask.updateExtents()
        layer_polygon_mask.setCrs(self.crs)

        # create the classification task, fill it with the required information and link one signal
        # to update the progress bar
        file_format = ".tif"
        self.classify_layer_task = ClassificationTask2("Classification task")
        self.classify_layer_task.task_progress_signal.connect(self.barProgressChangedFromClassificationTask)
        self.classify_layer_task.fillVariables(layer_polygon_mask, layer_name_selected,
                                               self.path_to_aux_layer, self.path_to_resources, file_format,
                                               self.path_to_trained_algorithms,
                                               self.path_to_sentinel_data, self.crs, height_in_pixels,
                                               length_in_pixels, multi_temporal_product_list)

        # with both the download data task and classification task created, add them in sequence to the task manager
        # the classification task will only commence once the download data task has finished
        self.classify_layer_task.addSubTask(self.get_sentinel_data_task, [], QgsTask.ParentDependsOnSubTask)
        QgsApplication.taskManager().addTask(self.classify_layer_task)

        return


# noinspection PyCallByClass
# task used in the creation of the simplified raster layer for the creation of the training dataset, skip this task
class SimplifyLabeledLayerTask(QgsTask):
    """This shows how to subclass QgsTask"""
    task_progress_signal = pyqtSignal(int)

    def __init__(self, description):  # , features, field_idx, provider):
        super().__init__(description, QgsTask.CanCancel)
        self.iterations = 0
        self.exception = None
        self.features = None
        self.field_idx = None
        self.provider = None
        self.log_category = "ATC Log"
        self.pre_message_log = "[SimplifyLabeledLayerTask]: "

    def run(self):
        """Here you implement your heavy lifting.
        Should periodically test for isCanceled() to gracefully
        abort.
        This method MUST return True or False.
        Raising exceptions will crash QGIS, so we handle them
        internally and raise them in self.finished
        """
        QgsMessageLog.logMessage('{}Started task "{}"'.format(self.pre_message_log,
                                                              self.description()),
                                 self.log_category, Qgis.Info)
        update_map = {}
        for feature in self.features:
            first_field_value = feature["COS2018_n1"]
            feat_id = feature.id()
            update_map[feat_id] = {self.field_idx: int(first_field_value[0])}
            self.iterations += 1
            self.task_progress_signal.emit(self.iterations)
            if self.isCanceled():
                return False

        QgsMessageLog.logMessage(self.pre_message_log + "Done with the features, waiting to update map",
                                 self.log_category, level=Qgis.Info)
        self.provider.changeAttributeValues(update_map)
        QgsMessageLog.logMessage(self.pre_message_log + "Finished creating and filling the new simplified field",
                                 self.log_category, level=Qgis.Info)
        return True

    def finished(self, result=None):
        """
        This function is automatically called when the task has
        completed (successfully or not).
        You implement finished() to do whatever follow-up stuff
        should happen after the task is complete.
        finished is always called from the main thread, so it's safe
        to do GUI operations and raise Python exceptions here.
        result is the return value from self.run.
        """
        if result:
            QgsMessageLog.logMessage(
                "{}{} completed with result and {} iterations.".format(
                    self.pre_message_log, self.description(), self.iterations), self.log_category, Qgis.Success)
            # using this signal to inform the progress bar that the task has finished
            self.task_progress_signal.emit(int(-1))
        else:
            if self.exception is None:
                QgsMessageLog.logMessage(
                    '{}"{}" not successful but without ' \
                    'exception (probably the task was manually ' \
                    'canceled by the user)'.format(self.pre_message_log,
                                                   self.description()),
                    self.log_category, Qgis.Warning)
            else:
                QgsMessageLog.logMessage(
                    '{}"{}" Exception: {exception}'.format(self.pre_message_log,
                                                           self.description(),
                                                           self.exception),
                    self.log_category, Qgis.Critical)
                raise self.exception

    def cancel(self):
        QgsMessageLog.logMessage(
            '{}"{}" was canceled'.format(self.pre_message_log,
                                         self.description()),
            self.log_category, Qgis.Info)
        super().cancel()

    def fillVariables(self, features, field_idx, provider):
        self.features = features
        self.field_idx = field_idx
        self.provider = provider


# noinspection PyCallByClass
# task used to clip the labeled raster layer for the creation of the training dataset, skip this task
class SnipLabeledLayerTask(QgsTask):
    """This shows how to subclass QgsTask"""

    def __init__(self, description):  # , features, field_idx, provider):
        super().__init__(description, QgsTask.CanCancel)
        self.exception = None
        self.active_layer = None
        self.layer_name_selected = None
        self.path_to_aux_layer = None
        self.path_to_resources = None
        self.file_format = None
        self.log_category = "ATC Log"
        self.params = None
        self.pre_message_log = "[SnipLabeledLayerTask]: "

    # noinspection PyTypeChecker
    def run(self):
        """Here you implement your heavy lifting.
        Should periodically test for isCanceled() to gracefully
        abort.
        This method MUST return True or False.
        Raising exceptions will crash QGIS, so we handle them
        internally and raise them in self.finished
        """
        QgsMessageLog.logMessage('{}Started task "{}"'.format(self.pre_message_log,
                                                              self.description()),
                                 self.log_category, level=Qgis.Info)

        # run processing
        runAlgs.runAlgorithm('gdal:cliprasterbymasklayer', self.params)

        if os.path.isfile(self.path_to_aux_layer + self.layer_name_selected + self.file_format):
            self.active_layer = QgsRasterLayer(
                self.path_to_aux_layer + self.layer_name_selected + self.file_format, self.layer_name_selected)
        else:
            QgsMessageLog.logMessage(self.pre_message_log + "Clipping algorythm failed! aborting", self.log_category,
                                     level=Qgis.Warning)
            return

        if self.active_layer.isValid():
            QgsMessageLog.logMessage(self.pre_message_log + "Layer Clipped.", self.log_category, level=Qgis.Info)
        else:
            QgsMessageLog.logMessage(self.pre_message_log + "Attributed layer is invalid.", self.log_category,
                                     level=Qgis.Info)
        return True

    def finished(self, result=None):
        """
        This function is automatically called when the task has
        completed (successfully or not).
        You implement finished() to do whatever follow-up stuff
        should happen after the task is complete.
        finished is always called from the main thread, so it's safe
        to do GUI operations and raise Python exceptions here.
        result is the return value from self.run.
        """
        if result:
            QgsProject.instance().addMapLayer(self.active_layer)
            QgsMessageLog.logMessage(
                "{}{} completed with result".format(
                    self.pre_message_log, self.description()), self.log_category, Qgis.Success)
        else:
            if self.exception is None:
                QgsMessageLog.logMessage(
                    '{}"{}" not successful but without ' \
                    'exception (probably the task was manually ' \
                    'canceled by the user)'.format(
                        self.pre_message_log, self.description()),
                    self.log_category, Qgis.Warning)
            else:
                QgsMessageLog.logMessage(
                    '{}"{}" Exception: {exception}'.format(
                        self.pre_message_log, self.description(),
                        self.exception),
                    self.log_category, Qgis.Critical)
                raise self.exception

    def cancel(self):
        QgsMessageLog.logMessage(
            '{}"{}" was canceled'.format(self.pre_message_log,
                                         self.description()),
            self.log_category, Qgis.Info)
        super().cancel()

    def fillVariables(self, params, active_labeled_layer, layer_name_selected,
                      path_to_aux_layer, path_to_resources, file_format):
        self.active_layer = active_labeled_layer
        self.layer_name_selected = layer_name_selected
        self.path_to_aux_layer = path_to_aux_layer
        self.path_to_resources = path_to_resources
        self.file_format = file_format
        self.params = params

# task used to clip all the sentinel band raster layers for the creation of the training dataset, skip this task
class SnipAllLayersTask(QgsTask):
    """This shows how to subclass QgsTask"""
    task_progress_signal = pyqtSignal(int)

    def __init__(self, description):  # , features, field_idx, provider):
        super().__init__(description, QgsTask.CanCancel)
        self.exception = None
        self.active_layer = None
        self.layer_name_selected = None
        self.path_to_aux_layer = None
        self.path_to_resources = None
        self.file_format = None
        self.path_to_dataframe_layer = None
        self.file_format_dataframe = None
        self.layer_polygon_mask = None
        self.tile_location = None
        self.list_of_tif_files_to_delete = None
        self.crs = None
        self.path_to_training_images = None
        self.log_category = "ATC Log"
        self.pre_message_log = "[SnipAllLayersTask]: "

    # noinspection PyTypeChecker
    def run(self):
        """Here you implement your heavy lifting.
        Should periodically test for isCanceled() to gracefully
        abort.
        This method MUST return True or False.
        Raising exceptions will crash QGIS, so we handle them
        internally and raise them in self.finished
        """
        QgsMessageLog.logMessage('{}Started task "{}"'.format(self.pre_message_log,
                                                              self.description()), self.log_category, level=Qgis.Info)

        # iterate through 12 bands throughout 6 seasons
        initial_path = self.path_to_training_images + self.tile_location
        all_seasons = ["/summer2/", "/spring2/", "/winter2/", "/autumn/", "/summer/", "/spring/"]

        # important list with all the paths of the bands across multiple folders
        all_band_paths = []

        for season in all_seasons:
            search_path = initial_path + season + "GRANULE/"
            for entry in os.scandir(search_path):
                # print all entries that are files
                if entry.is_dir():
                    search_path = search_path + entry.name + "/IMG_DATA/"
                    break

            # Name all 12 bands and respective resolution (Band 10 does not exist in L2A Data)
            all_bands = [("R60m/", "B01_60m"),
                         ("R10m/", "B02_10m"),
                         ("R10m/", "B03_10m"),
                         ("R10m/", "B04_10m"),
                         ("R20m/", "B05_20m"),
                         ("R20m/", "B06_20m"),
                         ("R20m/", "B07_20m"),
                         ("R10m/", "B08_10m"),
                         ("R20m/", "B8A_20m"),
                         ("R60m/", "B09_60m"),
                         ("R20m/", "B11_20m"),
                         ("R20m/", "B12_20m")]

            for bands in all_bands:
                band_path_like = search_path + bands[0] + "*" + bands[1] + ".jp2"
                for file in glob.glob(band_path_like):
                    all_band_paths.append(file.replace("\\", "/"))
                    break

        # append the labeled layer last
        all_band_paths.append(self.path_to_resources + "Portugal_Reduced_Labeling_Raster.tif")

        i = 0
        full_list = []
        # auxiliar tif file to delete
        aux_tif_files_to_delete = []
        for each_band_path in all_band_paths:
            i = i + 1
            layer_aux_name = "layer" + str(i)
            input_layer = QgsRasterLayer(each_band_path, layer_aux_name)
            output_choice = self.path_to_aux_layer + layer_aux_name + self.file_format

            params = {
                "INPUT": input_layer,
                "SOURCE_CRS": input_layer,
                "TARGET_CRS": self.crs,
                "RESAMPLING": 0,
                "NODATA": 0,
                "TARGET_RESOLUTION": 10,
                "OPTIONS": "",
                "DATA_TYPE": 0,
                "TARGET_EXTENT": self.layer_polygon_mask.extent(),
                "MULTITHREADING": False,
                "EXTRA": None,
                "OUTPUT": output_choice}

            # run processing
            runAlgs.runAlgorithm('gdal:warpreproject', params)

            if os.path.isfile(output_choice):
                layer_to_extract = QgsRasterLayer(output_choice, layer_aux_name)
            else:
                QgsMessageLog.logMessage(self.pre_message_log + "Clipping algorythm failed! aborting",
                                         self.log_category,
                                         level=Qgis.Warning)
                return

            if layer_to_extract.isValid():
                ds = gdal.Open(layer_to_extract.dataProvider().dataSourceUri(), gdal.GA_ReadOnly)
                rb = ds.GetRasterBand(1)
                img_array = rb.ReadAsArray().ravel()
                # print(img_array)
                full_list.append(img_array)
                aux_tif_files_to_delete.append(output_choice)
                self.task_progress_signal.emit(int(i))

                # create index every 12 bands (this part is especially hard coded because it was added later on)
                # there are 12 bands for each season (6 seasons in total) and 7 indexes are added after each season
                if (i == 12 or i == 24 or i == 36 or i == 48 or i == 60 or i == 72):
                    NDVI_index = []
                    MNDWI_index = []
                    MNDWI_index2 = []
                    NDMI_index = []
                    NDBI_index = []
                    BI_index = []
                    GVI_index = []

                    # the last 12 bands will always be at the end of the full_list, because the the previous indexes
                    # are appended before the bands are gathered
                    # The transition to float is made because the images come as UInt_16, this format would prevent
                    # negative values in the index's calculations (tested!)
                    for Blue_band, Green_band, Red_band, NIR_band, SWIR1_band, SWIR2_band in zip(
                            full_list[-11], full_list[-10], full_list[-9], full_list[-5], full_list[-2], full_list[-1]):

                        # calculate and append every index
                        # NDVI -> ((NIR - Red)/(NIR + Red))
                        if ((NIR_band + Red_band) != 0):
                            NDVI_index.append(((float(NIR_band) - Red_band) / (NIR_band + Red_band)))
                        else:
                            NDVI_index.append(0)

                        # MNDWI -> ((green - SWIR) / (green + SWIR))
                        if ((Green_band + SWIR1_band) != 0):
                            MNDWI_index.append(((float(Green_band) - SWIR1_band) / (Green_band + SWIR1_band)))
                        else:
                            MNDWI_index.append(0)

                        if ((Green_band + SWIR2_band) != 0):
                            MNDWI_index2.append(((float(Green_band) - SWIR2_band) / (Green_band + SWIR2_band)))
                        else:
                            MNDWI_index2.append(0)

                        # NDMI -> (NIR - SWIR1) / (NIR + SWIR1)
                        if ((NIR_band + SWIR1_band) != 0):
                            NDMI_index.append(((float(NIR_band) - SWIR1_band) / (NIR_band + SWIR1_band)))
                        else:
                            NDMI_index.append(0)

                        # NDBI -> (SWIR1 - NIR) / (SWIR1 + NIR)
                        if ((SWIR1_band + NIR_band) != 0):
                            NDBI_index.append(((float(SWIR1_band) - NIR_band) / (SWIR1_band + NIR_band)))
                        else:
                            NDBI_index.append(0)

                        # BI -> ((SWIR + RED) - (NIR + BLUE))/((SWIR + RED) + (NIR + BLUE))
                        if (((SWIR1_band + Red_band) + (NIR_band + Blue_band)) != 0):
                            BI_index.append((((float(SWIR1_band) + Red_band) - (NIR_band + Blue_band)) / (
                                        (SWIR1_band + Red_band) + (NIR_band + Blue_band))))
                        else:
                            BI_index.append(0)

                        # GVI -> (Green - Red) / (Green + Red)
                        if ((Green_band + Red_band) != 0):
                            GVI_index.append(((float(Green_band) - Red_band) / (Green_band + Red_band)))
                        else:
                            GVI_index.append(0)

                    # After all the indexes are created, append them to the list (before each new set of 12 bands)
                    full_list.append(NDVI_index)
                    full_list.append(MNDWI_index)
                    full_list.append(MNDWI_index2)
                    full_list.append(NDMI_index)
                    full_list.append(NDBI_index)
                    full_list.append(BI_index)
                    full_list.append(GVI_index)

                # QgsMessageLog.logMessage(self.pre_message_log + "Layer Clipped.", self.log_category, level=Qgis.Info)
            else:
                QgsMessageLog.logMessage(self.pre_message_log + "Attributed layer is invalid.", self.log_category,
                                         level=Qgis.Critical)

            # if i >= 5:
            #   break

        # close datasource
        ds = None

        for class_number in range(1, 10):  # 1 through 9
            class_specific_label = []
            for elements in full_list[114]:
                if elements == class_number:
                    class_specific_label.append(1)
                else:
                    class_specific_label.append(-1)
            full_list.append(class_specific_label)

        QgsMessageLog.logMessage(self.pre_message_log + "Creating CSV file, this might take a while.",
                                 self.log_category,
                                 level=Qgis.Info)

        csv_output = self.path_to_dataframe_layer + self.layer_name_selected + self.file_format_dataframe
        # list of auxiliary tif files created in "warpreproject" (cut and resize function) to delete
        self.list_of_tif_files_to_delete = aux_tif_files_to_delete

        # A full list has 73 indexes (0 to 72), 12 indexes per season plus the labeled layer
        # in the next code we group 3 seasons at a time plus the labeled layer (index 72)
        df = pd.DataFrame(full_list[0:57] + full_list[114:]).T
        df = df.append(pd.DataFrame(full_list[19:76] + full_list[114:]).T)
        df = df.append(pd.DataFrame(full_list[38:95] + full_list[114:]).T)
        df = df.append(pd.DataFrame(full_list[57:114] + full_list[114:]).T)
        df.to_csv(csv_output, index=False)

        QgsMessageLog.logMessage(self.pre_message_log + "Finishied creating CSV file!",
                                 self.log_category,
                                 level=Qgis.Info)

        return True

    def finished(self, result=None):
        """
        This function is automatically called when the task has
        completed (successfully or not).
        You implement finished() to do whatever follow-up stuff
        should happen after the task is complete.
        finished is always called from the main thread, so it's safe
        to do GUI operations and raise Python exceptions here.
        result is the return value from self.run.
        """

        if result:

            for file in self.list_of_tif_files_to_delete:
                if os.path.exists(file):
                    os.remove(file)
                if os.path.exists(file + ".aux.xml"):
                    os.remove(file + ".aux.xml")

            # The progress bar is incremented 73 times ( in the foor loop), after that (-1) is sent to close it
            self.task_progress_signal.emit(int(-1))

            QgsMessageLog.logMessage(
                "{}{} completed with result".format(
                    self.pre_message_log, self.description()), self.log_category, Qgis.Success)
        else:
            if self.exception is None:
                QgsMessageLog.logMessage(
                    '{}"{}" not successful but without ' \
                    'exception (probably the task was manually ' \
                    'canceled by the user)'.format(
                        self.pre_message_log, self.description()),
                    self.log_category, Qgis.Warning)
            else:
                QgsMessageLog.logMessage(
                    '{}"{}" Exception: {exception}'.format(
                        self.pre_message_log, self.description(),
                        self.exception),
                    self.log_category, Qgis.Critical)
                raise self.exception

    def cancel(self):
        QgsMessageLog.logMessage(
            '{}"{}" was canceled'.format(self.pre_message_log,
                                         self.description()),
            self.log_category, Qgis.Info)
        super().cancel()

    def fillVariables(self, layer_polygon_mask, active_labeled_layer, layer_name_selected,
                      path_to_aux_layer, path_to_resources, file_format, path_to_dataframe_layer,
                      path_to_training_images,
                      file_format_dataframe, tile_location, crs):
        self.active_layer = active_labeled_layer
        self.layer_name_selected = layer_name_selected
        self.path_to_aux_layer = path_to_aux_layer
        self.path_to_resources = path_to_resources
        self.file_format = file_format
        self.path_to_dataframe_layer = path_to_dataframe_layer
        self.file_format_dataframe = file_format_dataframe
        self.path_to_training_images = path_to_training_images
        self.layer_polygon_mask = layer_polygon_mask
        self.tile_location = tile_location
        self.crs = crs

# task used to retrieve the sentinel data from the database
class GetSentinelDataTask2(QgsTask):
    """This shows how to subclass QgsTask"""
    task_progress_signal = pyqtSignal(int)

    def __init__(self, description):
        super().__init__(description, QgsTask.CanCancel)
        self.exception = None
        self.log_category = "ATC Log"
        self.pre_message_log = "[GetSentinelDataTask]: "
        self.path_to_sentinel_data = cmd_folder.replace("\\", "/") + "/files/sentinel_data/"
        self.iface = None
        self.log_category = None
        self.multi_temporal_product_list = None
        self.api = None

    def run(self):
        """Here you implement your heavy lifting.
        Should periodically test for isCanceled() to gracefully
        abort.
        This method MUST return True or False.
        Raising exceptions will crash QGIS, so we handle them
        internally and raise them in self.finished
        """
        QgsMessageLog.logMessage('{}Started task "{}"'.format(self.pre_message_log,
                                                              self.description()),
                                 self.log_category, Qgis.Info)


        # send signal to initialize the classification progress bar and progress it to 10%
        self.task_progress_signal.emit(int(-2))
        self.task_progress_signal.emit(int(10))

        download_counter = 0
        for product_list in self.multi_temporal_product_list:

            QgsMessageLog.logMessage(self.pre_message_log + "Data acquisition will start! Progress: " + str(download_counter) + "/3",self.log_category, level=Qgis.Info)
            download_counter = download_counter + 1

            download_necessary_flag = True

            # iterate through each season product list in search of previously downloaded files, if found activate flag
            for index, product in product_list.iterrows():

                # get title of the product to check if it was already downloaded
                # example: S2B_MSIL2A_20210519T112119_N0300_R037_T29SND_20210519T142957
                identifier = product['identifier'].strip()
                files_zip = sorted(glob.iglob(self.path_to_sentinel_data + identifier + ".zip"), key=os.path.getctime, reverse=True)
                files_safe = sorted(glob.iglob(self.path_to_sentinel_data + identifier + ".SAFE"), key=os.path.getctime, reverse=True)

                if files_zip or files_safe:
                    download_necessary_flag = False
                    break

            # if there already exist one of the required files, skip the downloading procedure for that season
            if not download_necessary_flag:
                QgsMessageLog.logMessage(self.pre_message_log + "File previously downloaded, skipping.",self.log_category, level=Qgis.Info)
                # update progress bar
                self.task_progress_signal.emit(int(10 + download_counter * 30))
                continue

            # Downloading procedure, try to download each file in order, if successful skip the rest, else try backup
            for index, product in product_list.iterrows():

                # Download tile if online
                if self.api.is_online(product['uuid'].strip()):
                    self.api.download(product['uuid'].strip(), directory_path=self.path_to_sentinel_data[:-1])
                else:
                    QgsMessageLog.logMessage(self.pre_message_log + "Wanted file is offline, retrying.", self.log_category, level=Qgis.Info)
                    continue

                # Give some time to the file explorer to update the downloaded maps extension to zip (from the initial downloading state "incomplete")
                time.sleep(3)

                # Check to see if any file was downloaded or if the file was corrupted (< 100 mb), Sentinel database is full of errors recently...
                identifier = product['identifier'].strip()
                files_zip = sorted(glob.iglob(self.path_to_sentinel_data + identifier + ".zip"), key=os.path.getctime, reverse=True)
                if not files_zip:
                    QgsMessageLog.logMessage(self.pre_message_log + "File was not downloaded correctly (missing), retrying.", self.log_category, level=Qgis.Info)
                    continue
                else:
                    file_size = os.path.getsize(files_zip[0].replace("\\", "/"))
                    if file_size < 100000000:
                        QgsMessageLog.logMessage(self.pre_message_log + "File was not downloaded correctly (corrupted), retrying.", self.log_category, level=Qgis.Info)
                        # delete corrupted zip file
                        os.remove(files_zip[0].replace("\\", "/"))
                        # time for the file explorer to update
                        time.sleep(3)
                        # continue to next file backup
                        continue
                    else:
                        # file downloaded correctly, jumping season
                        QgsMessageLog.logMessage(self.pre_message_log + "File downloaded.",self.log_category, level=Qgis.Info)
                        break

            # update progress bar in steps of 30%
            self.task_progress_signal.emit(int(10 + download_counter * 30))


        QgsMessageLog.logMessage(self.pre_message_log + "Process Ended.", self.log_category, level=Qgis.Info)
        return True

    def finished(self, result=None):
        """
        This function is automatically called when the task has
        completed (successfully or not).
        You implement finished() to do whatever follow-up stuff
        should happen after the task is complete.
        finished is always called from the main thread, so it's safe
        to do GUI operations and raise Python exceptions here.
        result is the return value from self.run.
        """
        if result:
            QgsMessageLog.logMessage(
                "{}{} completed with result, widget bar deleted.".format(
                    self.pre_message_log, self.description()), self.log_category, Qgis.Success)

            # Send (-1) signal to close the progress bar in the main class
            self.task_progress_signal.emit(int(-1))
        else:
            if self.exception is None:
                QgsMessageLog.logMessage(
                    '{}"{}" not successful but without ' \
                    'exception (probably the task was manually ' \
                    'canceled by the user)'.format(self.pre_message_log,
                                                   self.description()),
                    self.log_category, Qgis.Warning)
            else:
                QgsMessageLog.logMessage(
                    '{}"{}" Exception: {exception}'.format(self.pre_message_log,
                                                           self.description(),
                                                           self.exception),
                    self.log_category, Qgis.Critical)
                raise self.exception

    def cancel(self):
        QgsMessageLog.logMessage(
            '{}"{}" was canceled'.format(self.pre_message_log,
                                         self.description()),
            self.log_category, Qgis.Info)
        super().cancel()

    def fillVariables(self, iface, log_category, multi_temporal_product_list, api):
        self.iface = iface
        self.log_category = log_category
        self.multi_temporal_product_list = multi_temporal_product_list
        self.api = api


class ClassificationTask2(QgsTask):
    """This shows how to subclass QgsTask"""
    task_progress_signal = pyqtSignal(int)

    def __init__(self, description):  # , features, field_idx, provider):
        super().__init__(description, QgsTask.CanCancel)
        self.exception = None
        self.ground_layer = None
        self.prediction_layer = None
        self.prediction_layer_mask = None
        self.layer_name_selected = None
        self.path_to_aux_layer = None
        self.path_to_resources = None
        self.file_format = None
        self.layer_polygon_mask = None
        self.list_of_tif_files_to_delete = None
        self.crs = None
        self.path_to_trained_algorithms = None
        self.path_to_sentinel_data = None
        self.height_in_pixels = None
        self.length_in_pixels = None
        self.log_category = "ATC Log"
        self.pre_message_log = "[ClassificationTask]: "
        self.multi_temporal_product_list = None

    # noinspection PyTypeChecker
    def run(self):
        """Here you implement your heavy lifting.
        Should periodically test for isCanceled() to gracefully
        abort.
        This method MUST return True or False.
        Raising exceptions will crash QGIS, so we handle them
        internally and raise them in self.finished
        """
        QgsMessageLog.logMessage('{}Started task "{}"'.format(self.pre_message_log,
                                                              self.description()), self.log_category, level=Qgis.Info)


        # send signal to initialize the classification progress bar
        self.task_progress_signal.emit(int(-2))


        # Give some time to the file explorer to update the downloaded maps extension to zip (from the initial downloading state "incomplete")
        time.sleep(3)

        # zip (and occasionally unzipped) list to be filed with the folder paths of the sentinel-2 tiles
        zip_list = []
        i = 0
        for product_list in self.multi_temporal_product_list:

            # iterate through each season product list in search of a previously downloaded file to unzip or to continue
            for index, product in product_list.iterrows():

                # search for the downloaded tile files, either new (zipped) or previously downloaded (unzipped), by name
                identifier = product['identifier'].strip()
                files_zip = sorted(glob.iglob(self.path_to_sentinel_data + identifier + ".zip"), key=os.path.getctime,reverse=True)
                files_safe = sorted(glob.iglob(self.path_to_sentinel_data + identifier + ".SAFE"), key=os.path.getctime,reverse=True)

                # if no files were found, raise exception; if unzipped file was found, skip unzipping process; if zip file was found, unzip it.
                if not files_safe:
                    if not files_zip:
                        # no files were found continue to the next backup tile
                        continue
                    else:
                        QgsMessageLog.logMessage(self.pre_message_log + "File zipped, starting unzipping process.", self.log_category, level=Qgis.Info)
                        # Workaround used to unzip files with paths longer than 260 characters, since sentinel sends their data with folders with LONG Names
                        with ZipfileLongPaths(files_zip[0].replace("\\", "/"), 'r') as zip_ref:
                            zip_ref.extractall(self.path_to_sentinel_data[:-1])
                        # delete original zip after extraction for memory sake
                        os.remove(files_zip[0].replace("\\", "/"))
                        # append the original zip file path to the list (it will be switched to SAFE later), and jump to next season
                        zip_list.append(files_zip[0].replace("\\", "/"))
                        break
                else:
                    QgsMessageLog.logMessage(self.pre_message_log + "File already unzipped, skipping unzip process.", self.log_category, level=Qgis.Info)
                    # append the SAFE (unzipped path) to the list, and jump to next season
                    zip_list.append(files_safe[0].replace("\\", "/"))
                    break

            # update progress bar 10% at a time up to 30%
            i = i + 10
            self.task_progress_signal.emit(int(i))

        if len(zip_list) < 3:
            QgsMessageLog.logMessage(
                self.pre_message_log + "Could not find 3 tiles in the download folder! Likely a sentinel database error. Aborting classification process.", self.log_category, level=Qgis.Warning)
            return False

        QgsMessageLog.logMessage(
            self.pre_message_log + "Finished unziping previous downloaded images, starting band gathering.",
            self.log_category, level=Qgis.Info)

        # list containing the paths to the 3 unziped folders with all the sentinel 2 data (3 diferent seasons)
        unziped_list = [w.replace('.zip', '.SAFE') for w in zip_list]

        # important list with all the paths of the bands across multiple folders
        # Example of a path:
        # (user_folder)/S2B_MSIL2A_20201230T112359_N0214_R037_T29SPD_20201230T132319.SAFE/GRANULE/L2A_T29SPD_A019940_20201230T112446/IMG_DATA/R60m/T29SPD_20201230T112359_B01_60m.jp2
        all_band_paths = []

        # initialize season number variable
        season_number = 0

        # fill the list above with all the paths
        # 3 paths should be present in "unzip_list" one for each "season" (roughly 3 months of difference)
        for season in unziped_list:
            season_number = season_number + 1
            search_path = season + "/GRANULE/"
            for entry in os.scandir(search_path):
                # add to the path, the name of the folder inside of GRANULE (sent from sentinel with a long text)
                # containing information about the product level, geographic tile name, gather date, etc.
                # breaks loop after finding 1 file
                if entry.is_dir():
                    search_path = search_path + entry.name + "/IMG_DATA/"
                    break

            # save the search path of the most recent acquisition date folder (the first in order)
            # in order to add the ground truth layer later on
            if season_number == 1:
                search_path_ground_truth = search_path

            # Name all 12 bands and respective resolution (Band 10 does not exist in L2A Data)
            all_bands = [("R60m/", "B01_60m"),
                         ("R10m/", "B02_10m"),
                         ("R10m/", "B03_10m"),
                         ("R10m/", "B04_10m"),
                         ("R20m/", "B05_20m"),
                         ("R20m/", "B06_20m"),
                         ("R20m/", "B07_20m"),
                         ("R10m/", "B08_10m"),
                         ("R20m/", "B8A_20m"),
                         ("R60m/", "B09_60m"),
                         ("R20m/", "B11_20m"),
                         ("R20m/", "B12_20m")]

            # "*" is the place for the long file names mentioned above (product level, geographic tile, etc.)
            for bands in all_bands:
                band_path_like = search_path + bands[0] + "*" + bands[1] + ".jp2"
                for file in glob.glob(band_path_like):
                    all_band_paths.append(file.replace("\\", "/"))
                    break

        # append the ground truth layer from the most recent data acquisition to the last list position
        band_path_like = search_path_ground_truth + "R10m/" + "*" + "TCI_10m" + ".jp2"
        for file in glob.glob(band_path_like):
            all_band_paths.append(file.replace("\\", "/"))
            break

        i = 0
        full_list = []
        # auxiliar tif file to delete
        aux_tif_files_to_delete = []
        for each_band_path in all_band_paths:
            i = i + 1
            layer_aux_name = "layer_" + self.layer_name_selected + str(i)
            input_layer = QgsRasterLayer(each_band_path, layer_aux_name)
            output_choice = self.path_to_aux_layer + layer_aux_name + self.file_format

            params = {
                "INPUT": input_layer,
                "SOURCE_CRS": input_layer,
                "TARGET_CRS": self.crs,
                "RESAMPLING": 0,
                "NODATA": 0,
                "TARGET_RESOLUTION": 10,
                "OPTIONS": "",
                "DATA_TYPE": 0,
                "TARGET_EXTENT": self.layer_polygon_mask.extent(),
                "MULTITHREADING": False,
                "EXTRA": None,
                "OUTPUT": output_choice}

            # run processing
            runAlgs.runAlgorithm('gdal:warpreproject', params)

            # jump the last run (37) to prevent the ground truth image from being extracted into full_list in the next process
            if i == 37:
                aux_tif_files_to_delete.append(output_choice)
                continue

            # load recently clipped layer, if the layer does not exist abort
            if os.path.isfile(output_choice):
                layer_to_extract = QgsRasterLayer(output_choice, layer_aux_name)
            else:
                QgsMessageLog.logMessage(self.pre_message_log + "Clipping algorythm failed! aborting",
                                         self.log_category,
                                         level=Qgis.Warning)
                return

            # transform the data from the newly cut raster layer (as a matrix) to a vector and append it to the dataset
            # every 12 runs (derived from the 12 bands) calculate the vegetation indices for that season and append them
            if layer_to_extract.isValid():
                ds = gdal.Open(layer_to_extract.dataProvider().dataSourceUri(), gdal.GA_ReadOnly)
                rb = ds.GetRasterBand(1)
                img_array = rb.ReadAsArray().ravel()
                # print(img_array)
                full_list.append(img_array)
                aux_tif_files_to_delete.append(output_choice)

                # update progress bar = to the number of iterations (1% to 36%)
                self.task_progress_signal.emit(int(30 + i))

                if (i == 12 or i == 24 or i == 36):
                    NDVI_index = []
                    MNDWI_index = []
                    MNDWI_index2 = []
                    NDMI_index = []
                    NDBI_index = []
                    BI_index = []
                    GVI_index = []

                    # the last 12 bands will always be at the end of the full_list, because the the previous indexes
                    # are appended before the bands are gathered
                    # The transition to float is made because the images come as UInt_16, this format would prevent
                    # negative values in the index's calculations (tested!)
                    for Blue_band, Green_band, Red_band, NIR_band, SWIR1_band, SWIR2_band in zip(
                            full_list[-11], full_list[-10], full_list[-9], full_list[-5], full_list[-2], full_list[-1]):

                        # calculate and append every index
                        # NDVI -> ((NIR - Red)/(NIR + Red))
                        if ((NIR_band + Red_band) != 0):
                            NDVI_index.append(((float(NIR_band) - Red_band) / (NIR_band + Red_band)))
                        else:
                            NDVI_index.append(0)

                        # MNDWI -> ((green - SWIR) / (green + SWIR))
                        if ((Green_band + SWIR1_band) != 0):
                            MNDWI_index.append(((float(Green_band) - SWIR1_band) / (Green_band + SWIR1_band)))
                        else:
                            MNDWI_index.append(0)

                        if ((Green_band + SWIR2_band) != 0):
                            MNDWI_index2.append(((float(Green_band) - SWIR2_band) / (Green_band + SWIR2_band)))
                        else:
                            MNDWI_index2.append(0)

                        # NDMI -> (NIR - SWIR1) / (NIR + SWIR1)
                        if ((NIR_band + SWIR1_band) != 0):
                            NDMI_index.append(((float(NIR_band) - SWIR1_band) / (NIR_band + SWIR1_band)))
                        else:
                            NDMI_index.append(0)

                        # NDBI -> (SWIR1 - NIR) / (SWIR1 + NIR)
                        if ((SWIR1_band + NIR_band) != 0):
                            NDBI_index.append(((float(SWIR1_band) - NIR_band) / (SWIR1_band + NIR_band)))
                        else:
                            NDBI_index.append(0)

                        # BI -> ((SWIR + RED) - (NIR + BLUE))/((SWIR + RED) + (NIR + BLUE))
                        if (((SWIR1_band + Red_band) + (NIR_band + Blue_band)) != 0):
                            BI_index.append((((float(SWIR1_band) + Red_band) - (NIR_band + Blue_band)) / (
                                        (SWIR1_band + Red_band) + (NIR_band + Blue_band))))
                        else:
                            BI_index.append(0)

                        # GVI -> (Green - Red) / (Green + Red)
                        if ((Green_band + Red_band) != 0):
                            GVI_index.append(((float(Green_band) - Red_band) / (Green_band + Red_band)))
                        else:
                            GVI_index.append(0)

                    # After all the indexes are created, append them to the list (before each new set of 12 bands)
                    full_list.append(NDVI_index)
                    full_list.append(MNDWI_index)
                    full_list.append(MNDWI_index2)
                    full_list.append(NDMI_index)
                    full_list.append(NDBI_index)
                    full_list.append(BI_index)
                    full_list.append(GVI_index)

                # QgsMessageLog.logMessage(self.pre_message_log + "Layer Clipped.", self.log_category, level=Qgis.Info)
            else:
                QgsMessageLog.logMessage(self.pre_message_log + "Attributed layer is invalid.", self.log_category,
                                         level=Qgis.Info)
                return

        # Get same layer projection and geotransform as the previous layers (used further in the code to create the
        # prediction layer)
        prev_layer_projection = ds.GetProjection()
        prev_layer_geotransform = ds.GetGeoTransform()

        QgsMessageLog.logMessage(self.pre_message_log + "Finished extracting data, starting classification procedure.",
                                 self.log_category, level=Qgis.Info)

        # A full list has 57 indexes (0 to 56), 12 indexes plus 7 indices per season
        # in the next code we group 3 seasons at a time plus the latest ground image
        x_data_pre_scale = pd.DataFrame(full_list[0:57]).T

        # path to Machine learning folder
        path_to_ml_folder = self.path_to_trained_algorithms + "QgisClassifier/teste_2/"

        # load previously tunned transformer
        transformer_path_to_save = path_to_ml_folder + "transformer.joblib"
        transformer = load(transformer_path_to_save)

        # scale data for better performance
        x_data = pd.DataFrame(transformer.transform(x_data_pre_scale))

        QgsMessageLog.logMessage(self.pre_message_log + "Finished scaling the data.", self.log_category,
                                 level=Qgis.Info)

        # update progress bar to 70%
        self.task_progress_signal.emit(int(70))

        # load all per-class classifiers and final classifier
        clf1 = load(path_to_ml_folder + "algorithm1.joblib")
        clf2 = load(path_to_ml_folder + "algorithm2.joblib")
        clf3 = load(path_to_ml_folder + "algorithm3.joblib")
        clf4 = load(path_to_ml_folder + "algorithm4.joblib")
        clf5 = load(path_to_ml_folder + "algorithm5.joblib")
        clf6 = load(path_to_ml_folder + "algorithm6.joblib")
        clf7 = load(path_to_ml_folder + "algorithm7.joblib")
        clf8 = load(path_to_ml_folder + "algorithm8.joblib")
        clf9 = load(path_to_ml_folder + "algorithm9.joblib")
        clf_final = load(path_to_ml_folder + "algorithm_final.joblib")

        # make and save per-class predictions
        prediction1_values = clf1.predict(x_data)
        prediction2_values = clf2.predict(x_data)
        prediction3_values = clf3.predict(x_data)
        prediction4_values = clf4.predict(x_data)
        prediction5_values = clf5.predict(x_data)
        prediction6_values = clf6.predict(x_data)
        prediction7_values = clf7.predict(x_data)
        prediction8_values = clf8.predict(x_data)
        prediction9_values = clf9.predict(x_data)

        # format per-class predictions to be fed into final classifier
        aux_prediction_all_values = [prediction1_values, prediction2_values, prediction3_values,
                                     prediction4_values, prediction5_values, prediction6_values,
                                     prediction7_values, prediction8_values, prediction9_values]
        prediction_all_values = pd.DataFrame(np.transpose(aux_prediction_all_values))

        # predict all classes
        prediction_final = clf_final.predict(prediction_all_values)

        # update progress bar to 80%
        self.task_progress_signal.emit(int(80))

        # inform
        QgsMessageLog.logMessage(
            self.pre_message_log + "Finished classification procedure, starting raster creation and mask application",
            self.log_category, level=Qgis.Info)

        # reshape prediction array into a 2D matrix,
        # although unlikely, could try deepcopy to prevent cascade effect in the mask application
        prediction_final_matrix = np.reshape(prediction_final, (self.height_in_pixels, self.length_in_pixels))

        # apply mask to replace every enclosed pixel (different from everyone around it) to the value
        # of the majority of the pixels around it
        # this is done to reduce "salt and pepper effect" of per-pixel classification. To prevent out of bounds, the
        # loop avoids the boundaries of the image -> range from 1 to height -1 ("-1" isn't necessary since python range
        # function stops before). (artificialized pixels (registered as 1, first line of the "if" statement)
        # are given the benefit of doubt, as in, are excluded from correction)
        for row in range(1, self.height_in_pixels - 1):
            for column in range(1, self.length_in_pixels - 1):
                if (
                        prediction_final_matrix[row - 1][column - 1] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row - 1][column] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row - 1][column + 1] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row][column - 1] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row][column + 1] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row + 1][column - 1] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row + 1][column] != prediction_final_matrix[row][column]
                        and prediction_final_matrix[row + 1][column + 1] != prediction_final_matrix[row][column]):
                    c = Counter([prediction_final_matrix[row - 1][column - 1],
                                 prediction_final_matrix[row - 1][column],
                                 prediction_final_matrix[row - 1][column + 1],
                                 prediction_final_matrix[row][column - 1],
                                 prediction_final_matrix[row][column + 1],
                                 prediction_final_matrix[row + 1][column - 1],
                                 prediction_final_matrix[row + 1][column],
                                 prediction_final_matrix[row + 1][column + 1]])
                    value_most_common, count_most_common = c.most_common()[0]
                    prediction_final_matrix[row][column] = value_most_common

        # create new raster layer with the prediction values pos mask
        path_to_prediction_raster = self.path_to_aux_layer + self.layer_name_selected + self.file_format
        driver = gdal.GetDriverByName('GTiff')
        ds_prediction = driver.Create(path_to_prediction_raster, xsize=self.length_in_pixels,
                                      ysize=self.height_in_pixels, bands=1, eType=gdal.GDT_Byte)
        ds_prediction.GetRasterBand(1).WriteArray(prediction_final_matrix)
        ds_prediction.SetGeoTransform(prev_layer_geotransform)
        srs_prediction = osr.SpatialReference(wkt=prev_layer_projection)
        ds_prediction.SetProjection(srs_prediction.ExportToWkt())

        # close datasources (from previous layers and from the new prediction layer)
        ds = None
        ds_prediction = None

        # update progress bar to 90%
        self.task_progress_signal.emit(int(90))

        QgsMessageLog.logMessage(self.pre_message_log + "Finished creating and filling prediciton raster.",
                                 self.log_category, level=Qgis.Info)

        # load ground truth labeled layer for analysis, it's placed in the last index of the list
        self.ground_layer = QgsRasterLayer(aux_tif_files_to_delete[-1], self.layer_name_selected + "_ground_truth")

        self.prediction_layer = QgsRasterLayer(path_to_prediction_raster, self.layer_name_selected + "_prediction")
        self.prediction_layer.loadNamedStyle(self.path_to_resources + "Portugal_Reduced_Labeling_Raster.qml")

        # remove the ground layer from path to prevent it from being deleted when we want to load it
        del aux_tif_files_to_delete[-1]

        # list of auxiliary tif files created in "warpreproject" (cut and resize function) to delete
        self.list_of_tif_files_to_delete = aux_tif_files_to_delete

        # update progress bar to 100%
        self.task_progress_signal.emit(int(100))

        return True

    def finished(self, result=None):
        """
        This function is automatically called when the task has
        completed (successfully or not).
        You implement finished() to do whatever follow-up stuff
        should happen after the task is complete.
        finished is always called from the main thread, so it's safe
        to do GUI operations and raise Python exceptions here.
        result is the return value from self.run.
        """
        if result:
            # delete all the auxiliary files created in the classification procedure
            for file in self.list_of_tif_files_to_delete:
                if os.path.exists(file):
                    os.remove(file)
                if os.path.exists(file + ".aux.xml"):
                    os.remove(file + ".aux.xml")

            # load the predicted layer and ground truth layer to the canvas
            QgsProject.instance().addMapLayer(self.ground_layer)
            QgsProject.instance().addMapLayer(self.prediction_layer)

            # The progress bar is incremented in the main thread, after that (-1) is sent to close it
            self.task_progress_signal.emit(int(-1))

            QgsMessageLog.logMessage(
                "{}{} completed with result".format(
                    self.pre_message_log, self.description()), self.log_category, Qgis.Success)
        else:
            if self.exception is None:
                QgsMessageLog.logMessage(
                    '{}"{}" not successful but without ' \
                    'exception (probably the task was manually ' \
                    'canceled by the user)'.format(
                        self.pre_message_log, self.description()),
                    self.log_category, Qgis.Warning)
            else:
                QgsMessageLog.logMessage(
                    '{}"{}" Exception: {exception}'.format(
                        self.pre_message_log, self.description(),
                        self.exception),
                    self.log_category, Qgis.Critical)
                raise self.exception

    def cancel(self):
        QgsMessageLog.logMessage(
            '{}"{}" was canceled'.format(self.pre_message_log,
                                         self.description()),
            self.log_category, Qgis.Info)
        super().cancel()

    def fillVariables(self, layer_polygon_mask, layer_name_selected,
                      path_to_aux_layer, path_to_resources, file_format,
                      path_to_trained_algorithms, path_to_sentinel_data, crs, height_in_pixels,
                      length_in_pixels, multi_temporal_product_list):
        self.layer_name_selected = layer_name_selected
        self.path_to_aux_layer = path_to_aux_layer
        self.path_to_resources = path_to_resources
        self.file_format = file_format
        self.layer_polygon_mask = layer_polygon_mask
        self.crs = crs
        self.path_to_trained_algorithms = path_to_trained_algorithms
        self.path_to_sentinel_data = path_to_sentinel_data
        self.height_in_pixels = height_in_pixels
        self.length_in_pixels = length_in_pixels
        self.multi_temporal_product_list = multi_temporal_product_list


# Workaround used to unzip files with paths longer than 260 characters, since sentinel sends their data with folders with LONG Names
# Thanks user1578026 from stack overflow, https://stackoverflow.com/questions/40419395/python-zipfile-extractall-ioerror-on-windows-when-extracting-files-from-long-pat
# the class ZipfileLongPath inherits from zipfile module
def winapi_path(dos_path, encoding=None):
    path = os.path.abspath(dos_path)

    if path.startswith("\\\\"):
        path = "\\\\?\\UNC\\" + path[2:]
    else:
        path = "\\\\?\\" + path

    return path


class ZipfileLongPaths(zipfile.ZipFile):

    def _extract_member(self, member, targetpath, pwd):
        targetpath = winapi_path(targetpath)
        return zipfile.ZipFile._extract_member(self, member, targetpath, pwd)

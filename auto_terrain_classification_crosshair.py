# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AutoTerrainClassification
                                 A QGIS plugin
 This plugin classifies sentinel 2 satellite imagery into 7 major terrain classes using machine learning algorithms for land use applications.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-13
        copyright            : (C) 2020 by Jorge Assunção
        email                : jms.assuncao@fct.unl.pt
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand
from qgis.core import QgsWkbTypes, QgsPointXY, QgsApplication


class GetCoordinateCrossHair(QgsMapToolEmitPoint):
    # initialized coordinate signal to be sent
    mouseClicked = pyqtSignal(QgsPointXY)


    def __init__(self, canvas):

        super(GetCoordinateCrossHair, self).__init__(canvas)
        self.mapCanvas = canvas

        # square settings
        self.rubberBand = QgsRubberBand(self.mapCanvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(Qt.blue)
        self.rubberBand.setWidth(5)

        # rectangle settings
        self.rubberBandRectangle = QgsRubberBand(self.mapCanvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBandRectangle.setColor(Qt.blue)
        self.rubberBandRectangle.setOpacity(0.5)
        self.rubberBandRectangle.setWidth(0)

        # crosshair style
        self.setCursor(QgsApplication.getThemeCursor(QgsApplication.Cursor.CrossHair))

        # initialize coordinate aux variables
        self.firstPoint = None
        self.secondPoint = None

        # used to clear rectangles (this is a fix, added after lenght and height limits)
        self.times_clicked = 0


    def canvasPressEvent(self, e):
        if e.button() == Qt.LeftButton:

            # if it's the 3rd time clicking, reset variables and drawn polygons (this was done after limits to prevent
            # funky movement of the drawn figures )
            if self.times_clicked == 2:
                self.times_clicked = 0
                self.firstPoint = None
                self.secondPoint = None
                self.rubberBand.reset(QgsWkbTypes.LineGeometry)
                self.rubberBandRectangle.reset(QgsWkbTypes.PolygonGeometry)

            # shift last saved coordinate
            self.secondPoint = self.firstPoint
            self.firstPoint = QgsPointXY(self.mapCanvas.getCoordinateTransform().toMapCoordinates(e.x(), e.y()))

            # save coordinate to variable, and see if the distance between is greater than the allowed polygon
            # (this is done to prevent the creation of a polygon that overlaps multiple geographic tiles)
            # when a way to join tiles is added, this step can be removed (it's possible, but comes with some code
            # and a lot of overhead computation/memory to implement)

            if self.secondPoint is not None:
                # calculate distance
                x_distance = self.secondPoint.x() - self.firstPoint.x()
                y_distance = self.secondPoint.y() - self.firstPoint.y()

                # aux variables used to hold the values until the last QgsPointXY call, initialized as originals
                # in case the boundaries only breaks one axis
                x_aux_value = self.firstPoint.x()
                y_aux_value = self.firstPoint.y()

                # flag to notify the need to create a new coordinate if any "if statement" is triggered
                need_change = False

                # check if distance is greater than the max 11000 units (empirical, it's possible that it's not enough)
                # if true, limit it to max
                if (x_distance > 11000) or (x_distance < -11000):
                    need_change = True
                    # check to see if the diference is positive or negative
                    if x_distance >= 0:
                        x_aux_value = self.secondPoint.x() - 11000
                    else:
                        x_aux_value = self.secondPoint.x() + 11000

                if (y_distance > 11000) or (y_distance < -11000):
                    need_change = True
                    if y_distance >= 0:
                        y_aux_value = self.secondPoint.y() - 11000
                    else:
                        y_aux_value = self.secondPoint.y() + 11000

                # if the need change flag is not triggered use previous saved value of "firstPoint"
                if need_change:
                    self.firstPoint = QgsPointXY(x_aux_value, y_aux_value)


            # send signal with coordinates to the main thread
            self.mouseClicked.emit(self.firstPoint)

            # reset previous drawn square
            self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)

            # create the small square that appears when a coordinate is selected (10*10)
            self.rubberBand.addPoint(QgsPointXY(float(self.firstPoint.x() - 10), float(self.firstPoint.y()) - 10), False)
            self.rubberBand.addPoint(QgsPointXY(float(self.firstPoint.x() + 10), float(self.firstPoint.y()) - 10), False)
            self.rubberBand.addPoint(QgsPointXY(float(self.firstPoint.x() + 10), float(self.firstPoint.y()) + 10), False)
            self.rubberBand.addPoint(QgsPointXY(float(self.firstPoint.x() - 10), float(self.firstPoint.y()) + 10), True)

            # show square
            self.rubberBand.show()

            # if there is 2 coordinates saved, create a rectangle joining them
            if self.secondPoint is not None:

                # reset previous drawn square
                self.rubberBandRectangle.reset(QgsWkbTypes.PolygonGeometry)

                # create a rectangle with the given coordinates
                self.rubberBandRectangle.addPoint(QgsPointXY(self.firstPoint.x(), self.firstPoint.y()), False)
                self.rubberBandRectangle.addPoint(QgsPointXY(self.firstPoint.x(), self.secondPoint.y()), False)
                self.rubberBandRectangle.addPoint(QgsPointXY(self.secondPoint.x(), self.secondPoint.y()), False)
                self.rubberBandRectangle.addPoint(QgsPointXY(self.secondPoint.x(), self.firstPoint.y()), True)

                # show rectangle
                self.rubberBandRectangle.show()

            self.times_clicked = self.times_clicked + 1

        elif e.button() == Qt.RightButton:
            # if right button is pressed, deactivate coordinate selection
            self.deactivate()

    def deactivate(self):
        # reset variables, clear drawn polygons, exit tool (the crosshair will still appear in the canvas,
        # it needs to be deactivated in the main call)
        self.firstPoint = None
        self.secondPoint = None
        self.rubberBand.reset(QgsWkbTypes.LineGeometry)
        self.rubberBandRectangle.reset(QgsWkbTypes.PolygonGeometry)
        self.times_clicked = 0
        super(GetCoordinateCrossHair, self).deactivate()
